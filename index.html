<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Luchtafweer Kanon Spel</title>
  <style>
    body{margin:0;overflow:hidden;background:#000}
    canvas{display:block}
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // Kanon
  const cannon = {
    x: 0, // wordt gezet in resize()
    y: 0, // wordt gezet in resize()
    angle: 0,
    width: 20,
    height: 60
  };

  // Canvas & positie updaten
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    cannon.x = canvas.width / 2;
    cannon.y = canvas.height - 50;
    rescaleEnemies(); // schaal bestaande vijanden mee bij schermverandering
  }
  window.addEventListener('resize', resize);

  // --- Laad vliegtuigplaatje ---
  const planeImg = new Image();
  let planeReady = false;
  planeImg.onload = () => { planeReady = true; };
  planeImg.onerror = () => {
    console.warn('Kon plane.png niet laden. Valt terug op blokjes.');
    planeReady = false;
  };
  planeImg.src = 'plane.png'; // zelfde map als deze HTML

  // --- Schaalinstelling voor het vliegtuig ---
  let planeScale = 2.0; // Pas aan voor groter/kleiner

  function getEnemySize() {
    const baseW = 60, baseH = 36; // basismaat
    return {
      width: Math.round(baseW * planeScale),
      height: Math.round(baseH * planeScale)
    };
  }

  const bullets = [];
  const enemies = [];
  let enemySpeed = 2;
  let enemySpawnRate = 100; // frames per spawn
  let frameCount = 0;
  let score = 0;
  let touchActive = false;

  function drawCannon() {
    ctx.save();
    ctx.translate(cannon.x, cannon.y);
    ctx.rotate((cannon.angle) * Math.PI / 180);
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.moveTo(0, -cannon.height);
    ctx.lineTo(-cannon.width / 2, 0);
    ctx.lineTo(cannon.width / 2, 0);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function spawnEnemy() {
    const { width, height } = getEnemySize();
    const x = Math.random() * (canvas.width - width);
    enemies.push({ x, y: -height, width, height });
  }

  function rescaleEnemies() {
    const { width, height } = getEnemySize();
    enemies.forEach(e => { e.width = width; e.height = height; });
  }

  function drawEnemies() {
    enemies.forEach(enemy => {
      if (planeReady) {
        ctx.drawImage(planeImg, enemy.x, enemy.y, enemy.width, enemy.height);
      } else {
        // fallback
        ctx.fillStyle = 'white';
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
      }
    });
  }

  function drawBullets() {
    ctx.fillStyle = 'blue';
    bullets.forEach(bullet => {
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function update() {
    frameCount++;

    // Update bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const bullet = bullets[i];
      bullet.x += bullet.dx;
      bullet.y += bullet.dy;
      if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
        bullets.splice(i, 1);
      }
    }

    // Spawn enemies
    if (frameCount % enemySpawnRate === 0) spawnEnemy();

    // Update enemies + collision
    for (let i = enemies.length - 1; i >= 0; i--) {
      const enemy = enemies[i];
      enemy.y += enemySpeed;
      if (enemy.y > canvas.height) {
        enemies.splice(i, 1);
        continue;
      }
      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        if (
          b.x > enemy.x &&
          b.x < enemy.x + enemy.width &&
          b.y > enemy.y &&
          b.y < enemy.y + enemy.height
        ) {
          enemies.splice(i, 1);
          bullets.splice(j, 1);
          score++;
          break;
        }
      }
    }
  }

  function drawScore() {
    ctx.fillStyle = 'white';
    ctx.font = '24px Arial';
    ctx.fillText(`Score: ${score}`, 10, 30);
  }

  function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawCannon();
    drawBullets();
    drawEnemies();
    drawScore();
    update();
    requestAnimationFrame(gameLoop);
  }

  function setDifficulty() {
    const input = prompt("Kies een moeilijkheidsniveau (1-5):", "1");
    const difficulty = parseInt(input || "1", 10);
    if (difficulty >= 1 && difficulty <= 5) {
      enemySpeed = difficulty * 2;
      enemySpawnRate = 120 - difficulty * 20;
    } else {
      alert("Ongeldige invoer! Standaard moeilijkheid (1) ingesteld.");
      enemySpeed = 2;
      enemySpawnRate = 100;
    }
  }

  function shoot() {
    const radians = (cannon.angle - 90) * Math.PI / 180;
    const dx = Math.cos(radians) * 7;
    const dy = Math.sin(radians) * 7;
    bullets.push({ x: cannon.x, y: cannon.y, dx, dy });
  }

  function handleTouchStart(event) {
    touchActive = true;
    const touch = event.touches[0];
    updateCannonAngle(touch.clientX, touch.clientY);
  }
  function handleTouchMove(event) {
    if (touchActive) {
      const touch = event.touches[0];
      updateCannonAngle(touch.clientX, touch.clientY);
    }
  }
  function handleTouchEnd() {
    touchActive = false;
    shoot();
  }
  function updateCannonAngle(touchX, touchY) {
    const dx = touchX - cannon.x;
    const dy = touchY - cannon.y;
    cannon.angle = Math.atan2(dy, dx) * 180 / Math.PI + 90;
  }

  window.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft') {
      cannon.angle = (cannon.angle - 7 + 360) % 360;
    } else if (e.key === 'ArrowRight') {
      cannon.angle = (cannon.angle + 7) % 360;
    } else if (e.key === ' ') {
      shoot();
    } else if (e.key === '+') {
      planeScale = Math.min(5, planeScale + 0.1);
      rescaleEnemies();
    } else if (e.key === '-') {
      planeScale = Math.max(0.2, planeScale - 0.1);
      rescaleEnemies();
    }
  });

  // Touch support
  canvas.addEventListener('touchstart', handleTouchStart, { passive: true });
  canvas.addEventListener('touchmove', handleTouchMove, { passive: true });
  canvas.addEventListener('touchend', handleTouchEnd);

  // Start
  resize();
  setDifficulty();
  gameLoop();
});
</script>
</body>
</html>
